"use strict";
const Logger = require('../../utils/Logger');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const needle = require('needle');
const AuthError = require('../../errors/AuthError');

function randomString(length) {
	return crypto.randomBytes(length).toString('hex');
}

var LoginGov = {

	// ///////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Get user info from an login.gov access token, this should fail if the token is not valid
	 * @param {*} accessToken
	 */
	async getUserInfo(accessToken) {
        
		let opts = {
			json: true,
			headers: {
				Authorization: `Bearer ${accessToken}`
			}
		};

		//Logger.debug('Getting user ', accessToken)

		let results = await needle('get', 'https://idp.int.identitysandbox.gov/api/openid_connect/userinfo', opts);

		//Logger.info('Getting user result: ', results.body)

		if (results.body.error) {
			Logger.warn(results.body);

			let msg = results.body.error;

			if (msg.search('expired') !== -1) {
				throw new AuthError('Session has expired');
			}

			throw new AuthError(msg);
		}

		return results.body;
	},    

	// ///////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Exchange OpenID code for a token
	 * @see https://developers.login.gov/oidc/
	 * @param {*} req
	 * @param {*} res
	 * @param {*} next
	 */
	async getTokenFromCode(code) {

		// A JWT signed with the client’s private key and containing the following claims:
		// iss (string) — The issuer, which must be the client_id.
		// sub (string) — The subject, which must also be the client_id.
		// aud (string) — The audience, which should be the URL of the token endpoint, for
		//                example: https://idp.int.identitysandbox.gov/api/openid_connect/token
		// jti (string) — The JWT ID, a unique identifier for the token which can be used to prevent
		//                reuse of the token. Should be an un-guessable, random string generated by the client.
		// exp (number) — The expiration time for this token. Should be an integer timestamp (number of seconds since
		//                the Unix Epoch) and be a short period of time in the future (such as 5 minutes from now).
		let claims = {
			iss: process.env.LOGIN_APP_ID,
			sub: process.env.LOGIN_APP_ID,
			aud: 'https://idp.int.identitysandbox.gov/api/openid_connect/token',
			exp: Math.round(Date.now()/1000) + parseInt(process.env.TOKEN_DURATION),
			jti: randomString(32)
		};

		// https://github.com/auth0/node-jsonwebtoken

		let token = jwt.sign(claims, process.env.JWT_PRIVATE_KEY, {
			algorithm: 'RS256'
		});

		let opts = {
			client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
			code: code,
			grant_type: 'authorization_code',
			client_assertion: token,
			exp: claims.exp
		};

		let result = await needle('post', 'https://idp.int.identitysandbox.gov/api/openid_connect/token', opts, { json: true });

		if (result.body && result.body.error) {
			Logger.error(opts);
			throw new Error(result.body.error);
		}

		return result.body;

		//res.status(403).json(result.body)
	},    

}

if (require.main === module) {
    


}
else {
    module.exports = LoginGov;
}